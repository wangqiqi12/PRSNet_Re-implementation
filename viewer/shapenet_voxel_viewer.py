# NOTE: Generated by Claude Sonnet 4

"""
ShapeNet 体素3D模型可视化工具

这个脚本提供了一个Gradio界面来浏览和可视化ShapeNetCore飞机模型的体素数据。
支持交互式3D查看，包括旋转、缩放、平移等操作。

功能特点：
- 读取.binvox文件（solid和surface两种类型）
- 支持分辨率降采样（128×128×128 → 32×32×32）
- 3D体素可视化
- 交互式控制
"""

import os
import json
import random
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import gradio as gr
from pathlib import Path
from scipy import ndimage
import binvox_rw


class ShapeNetVoxelViewer:
    def __init__(self, dataset_path):
        self.dataset_path = Path(dataset_path)
        self.model_ids = self._get_model_ids()
        print(f"找到 {len(self.model_ids)} 个3D体素模型")
    
    def _get_model_ids(self):
        """获取所有模型ID列表"""
        shapenet_plane_path = self.dataset_path / "shapenet_plane"
        if not shapenet_plane_path.exists():
            return []
        
        model_ids = []
        for item in shapenet_plane_path.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                solid_path = item / "models" / "model_normalized.solid.binvox"
                surface_path = item / "models" / "model_normalized.surface.binvox"
                if solid_path.exists() or surface_path.exists():
                    model_ids.append(item.name)
        return sorted(model_ids)
    
    def load_binvox_file(self, model_id, voxel_type='solid'):
        """加载binvox文件"""
        if voxel_type == 'solid':
            binvox_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.solid.binvox"
        else:
            binvox_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.surface.binvox"
        
        if not binvox_path.exists():
            return None, None
        
        try:
            with open(binvox_path, 'rb') as f:
                voxel_model = binvox_rw.read_as_3d_array(f)
            return voxel_model, binvox_path
        except Exception as e:
            print(f"加载binvox文件时出错: {e}")
            return None, None
    
    def center_voxels(self, voxel_data):
        """将体素数据居中到网格中心"""
        if voxel_data is None or not np.any(voxel_data):
            return voxel_data
        
        # 获取占用体素的坐标
        occupied_coords = np.where(voxel_data)
        if len(occupied_coords[0]) == 0:
            return voxel_data
        
        x, y, z = occupied_coords
        
        # 计算当前边界框
        x_min, x_max = x.min(), x.max()
        y_min, y_max = y.min(), y.max()
        z_min, z_max = z.min(), z.max()
        
        # 计算当前物体的中心
        current_center = np.array([
            (x_min + x_max) / 2,
            (y_min + y_max) / 2,
            (z_min + z_max) / 2
        ])
        
        # 计算网格的中心
        grid_center = np.array([
            voxel_data.shape[0] / 2,
            voxel_data.shape[1] / 2,
            voxel_data.shape[2] / 2
        ])
        
        # 计算偏移量
        offset = grid_center - current_center
        offset = np.round(offset).astype(int)
        
        # 创建新的居中体素数据
        centered_voxels = np.zeros_like(voxel_data)
        
        # 应用偏移，确保不超出边界
        for i in range(len(x)):
            new_x = x[i] + offset[0]
            new_y = y[i] + offset[1]
            new_z = z[i] + offset[2]
            
            # 检查边界
            if (0 <= new_x < voxel_data.shape[0] and 
                0 <= new_y < voxel_data.shape[1] and 
                0 <= new_z < voxel_data.shape[2]):
                centered_voxels[new_x, new_y, new_z] = True
        
        return centered_voxels
    
    def downsample_voxels(self, voxel_data, target_size=32):
        if voxel_data is None:
            return None
        
        original_shape = voxel_data.shape
        if all(s == target_size for s in original_shape):
            return voxel_data
        
        # 计算下采样比例
        scale_factors = [original_shape[i] / target_size for i in range(3)]
        
        # 使用最近邻插值进行下采样
        # 先转换为float类型进行插值，然后转回bool
        voxel_float = voxel_data.astype(float)
        downsampled = ndimage.zoom(voxel_float, 
                                 [1/scale_factors[i] for i in range(3)], 
                                 order=0,  # 最近邻插值
                                 mode='constant',
                                 cval=0.0)
        
        # 确保输出尺寸正确
        if any(downsampled.shape[i] != target_size for i in range(3)):
            # 如果尺寸不完全匹配，使用填充或裁剪
            result = np.zeros((target_size, target_size, target_size), dtype=bool)
            
            min_x = min(downsampled.shape[0], target_size)
            min_y = min(downsampled.shape[1], target_size)
            min_z = min(downsampled.shape[2], target_size)
            
            result[:min_x, :min_y, :min_z] = downsampled[:min_x, :min_y, :min_z] > 0.5
            return result
        
        return downsampled > 0.5
    
    def load_model_metadata(self, model_id):
        """加载模型元数据"""
        json_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.json"
        
        if not json_path.exists():
            return None
        
        try:
            with open(json_path, 'r') as f:
                metadata = json.load(f)
            return metadata
        except Exception as e:
            print(f"加载元数据时出错: {e}")
            return None
    
    def create_voxel_plot(self, model_id, voxel_type='solid', target_resolution=32, 
                         opacity=0.8, colorscale='Viridis', show_only_surface=False, center_voxels=True):
        """创建3D体素可视化图"""
        voxel_model, binvox_path = self.load_binvox_file(model_id, voxel_type)
        metadata = self.load_model_metadata(model_id)
        
        if voxel_model is None:
            # 返回空图表
            fig = go.Figure()
            fig.add_annotation(text="无法加载体素模型", x=0.5, y=0.5, showarrow=False)
            return fig, "体素模型加载失败"
        
        # 获取原始体素数据
        original_voxels = voxel_model.data
        original_dims = voxel_model.dims
        
        # 下采样到目标分辨率
        if target_resolution != original_dims[0]:
            downsampled_voxels = self.downsample_voxels(original_voxels, target_resolution)
        else:
            downsampled_voxels = original_voxels
        
        if downsampled_voxels is None:
            fig = go.Figure()
            fig.add_annotation(text="体素下采样失败", x=0.5, y=0.5, showarrow=False)
            return fig, "体素下采样失败"
        
        # 居中体素（如果需要）
        if center_voxels:
            downsampled_voxels = self.center_voxels(downsampled_voxels)
        
        # 获取占用体素的坐标
        if show_only_surface and voxel_type == 'solid':
            # 如果选择只显示表面，计算表面体素
            from scipy import ndimage
            # 膨胀后减去原始，得到表面
            kernel = ndimage.generate_binary_structure(3, 1)  # 6连通
            eroded = ndimage.binary_erosion(downsampled_voxels, kernel)
            surface_voxels = downsampled_voxels & ~eroded
            occupied_coords = np.where(surface_voxels)
        else:
            occupied_coords = np.where(downsampled_voxels)
        
        if len(occupied_coords[0]) == 0:
            fig = go.Figure()
            fig.add_annotation(text="没有占用的体素", x=0.5, y=0.5, showarrow=False)
            return fig, "没有占用的体素"
        
        x, y, z = occupied_coords
        
        # 创建颜色映射（基于Z坐标）
        colors = z.astype(float)
        
        # 创建3D散点图表示体素
        fig = go.Figure()
        
        scatter = go.Scatter3d(
            x=x, y=y, z=z,
            mode='markers',
            marker=dict(
                size=8,
                color=colors,
                colorscale=colorscale,
                opacity=opacity,
                showscale=True,
                colorbar=dict(title="Z坐标")
            ),
            name=f'{voxel_type.title()} 体素',
            hovertemplate='<b>体素坐标</b><br>' +
                         'X: %{x}<br>' +
                         'Y: %{y}<br>' +
                         'Z: %{z}<extra></extra>'
        )
        fig.add_trace(scatter)
        
        # 设置布局
        fig.update_layout(
            title=f'体素模型: {model_id} ({voxel_type}, {target_resolution}³)',
            scene=dict(
                xaxis_title='X轴',
                yaxis_title='Y轴', 
                zaxis_title='Z轴',
                camera=dict(
                    eye=dict(x=1.5, y=1.5, z=1.5)
                ),
                aspectmode='cube',  # 保持立方体比例
                xaxis=dict(range=[0, target_resolution]),
                yaxis=dict(range=[0, target_resolution]),
                zaxis=dict(range=[0, target_resolution])
            ),
            width=800,
            height=600,
            margin=dict(l=0, r=0, t=40, b=0)
        )
        
        # 创建信息文本
        info_text = f"**模型ID:** {model_id}\n"
        info_text += f"**体素类型:** {voxel_type.title()}\n"
        info_text += f"**原始分辨率:** {original_dims[0]}×{original_dims[1]}×{original_dims[2]}\n"
        info_text += f"**当前分辨率:** {target_resolution}×{target_resolution}×{target_resolution}\n"
        info_text += f"**原始占用体素数:** {np.sum(original_voxels)}\n"
        info_text += f"**当前占用体素数:** {len(x)}\n"
        info_text += f"**原始占用率:** {np.sum(original_voxels) / original_voxels.size * 100:.2f}%\n"
        info_text += f"**当前占用率:** {len(x) / (target_resolution**3) * 100:.2f}%\n"
        
        if metadata:
            info_text += f"**边界框最小值:** {metadata.get('min', 'N/A')}\n"
            info_text += f"**边界框最大值:** {metadata.get('max', 'N/A')}\n"
            info_text += f"**中心点:** {metadata.get('centroid', 'N/A')}\n"
        
        info_text += f"\n**文件路径:** {binvox_path}"
        
        return fig, info_text
    
    def get_random_model(self):
        """获取随机模型ID"""
        if self.model_ids:
            return random.choice(self.model_ids)
        return ""
    
    def get_model_list(self):
        """获取模型列表用于下拉选择"""
        return self.model_ids


def create_gradio_interface():
    """创建Gradio界面"""
    
    # 初始化查看器
    # NOTE: 请确保数据集路径正确
    # 这里使用了一个示例路径，请根据实际情况修改
    dataset_path = "./data/ShapeNet-toydata"
    viewer = ShapeNetVoxelViewer(dataset_path)
    
    if not viewer.model_ids:
        print("未找到任何体素模型文件！请检查数据集路径。")
        return None
    
    # 定义界面函数
    def visualize_voxels(model_id, voxel_type, target_resolution, opacity, colorscale, show_only_surface, center_voxels):
        if not model_id:
            return None, "请选择一个模型"
        
        try:
            fig, info = viewer.create_voxel_plot(
                model_id, voxel_type, target_resolution, 
                opacity, colorscale, show_only_surface, center_voxels
            )
            return fig, info
        except Exception as e:
            return None, f"可视化错误: {str(e)}"
    
    def load_random_model():
        return viewer.get_random_model()
    
    # 创建Gradio界面
    with gr.Blocks(title="ShapeNet 体素模型浏览器", theme=gr.themes.Soft()) as demo:
        gr.Markdown("""
        # 🧊 ShapeNet 体素模型浏览器
        
        这是一个交互式体素模型查看工具，用于浏览ShapeNetCore飞机数据集的体素表示。
        
        ## 功能特点：
        - 📊 交互式3D体素可视化（支持旋转、缩放、平移）
        - 🔄 分辨率下采样（128³ → 32³ 或其他尺寸）
        - 🎨 多种颜色方案和透明度调节
        - 🧊 支持Solid（实心）和Surface（表面）两种体素类型
        - 📋 详细的体素统计信息
        - 🎲 随机模型浏览
        
        ## 使用说明：
        1. 选择模型ID和体素类型
        2. 调整分辨率和可视化选项
        3. 在3D图中拖拽鼠标旋转视角，滚轮缩放，右键平移
        
        ## 体素类型说明：
        - **Solid**: 实心体素，包含模型内部的所有体素
        - **Surface**: 表面体素，仅包含模型表面的体素
        """)
        
        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### 🎮 控制面板")
                
                model_dropdown = gr.Dropdown(
                    choices=viewer.get_model_list(),
                    label="选择模型ID",
                    value=viewer.get_random_model(),
                    info="从下拉列表中选择要查看的3D体素模型"
                )
                
                random_btn = gr.Button("🎲 随机选择模型", variant="secondary")
                
                with gr.Group():
                    gr.Markdown("#### 体素选项")
                    voxel_type_radio = gr.Radio(
                        choices=['solid', 'surface'],
                        value='solid',
                        label="体素类型",
                        info="选择要显示的体素类型"
                    )
                    
                    resolution_slider = gr.Slider(
                        minimum=16,
                        maximum=128,
                        step=16,
                        value=32,
                        label="目标分辨率",
                        info="体素网格的分辨率（N×N×N）"
                    )
                    
                    show_surface_checkbox = gr.Checkbox(
                        label="仅显示表面（仅对Solid有效）",
                        value=False,
                        info="从实心体素中提取并仅显示表面体素"
                    )
                    
                    center_checkbox = gr.Checkbox(
                        label="居中显示",
                        value=True,
                        info="将体素模型居中到网格中心位置"
                    )
                
                with gr.Group():
                    gr.Markdown("#### 可视化选项")
                    opacity_slider = gr.Slider(
                        minimum=0.1,
                        maximum=1.0,
                        step=0.1,
                        value=0.8,
                        label="透明度",
                        info="体素的透明度"
                    )
                    
                    colorscale_dropdown = gr.Dropdown(
                        choices=['Viridis', 'Plasma', 'Inferno', 'Magma', 'Rainbow', 'Turbo', 'Spectral', 'Blues', 'Reds'],
                        value='Viridis',
                        label="颜色方案",
                        info="选择体素的颜色映射"
                    )
                
                visualize_btn = gr.Button("🚀 可视化", variant="primary", size="lg")
                
                gr.Markdown(f"""
                ### 📊 数据集信息
                - **总模型数量**: {len(viewer.model_ids)}
                - **数据格式**: Binvox体素
                - **原始分辨率**: 128×128×128
                - **体素类型**: Solid + Surface
                """)
            
            with gr.Column(scale=2):
                plot_output = gr.Plot(label="3D体素模型可视化")
                info_output = gr.Markdown("选择一个模型开始可视化...")
        
        # 事件绑定
        random_btn.click(
            fn=load_random_model,
            outputs=model_dropdown
        )
        
        visualize_btn.click(
            fn=visualize_voxels,
            inputs=[model_dropdown, voxel_type_radio, resolution_slider, 
                   opacity_slider, colorscale_dropdown, show_surface_checkbox, center_checkbox],
            outputs=[plot_output, info_output]
        )
        
        # 自动加载第一个模型
        demo.load(
            fn=visualize_voxels,
            inputs=[model_dropdown, voxel_type_radio, resolution_slider, 
                   opacity_slider, colorscale_dropdown, show_surface_checkbox, center_checkbox],
            outputs=[plot_output, info_output]
        )
    
    return demo


if __name__ == "__main__":
    # 创建并启动界面
    demo = create_gradio_interface()
    
    if demo:
        print("启动ShapeNet 体素模型浏览器...")
        print("在浏览器中访问界面来浏览体素模型")
        demo.launch(
            server_name="127.0.0.1",
            server_port=7861,  # 使用不同端口避免冲突
            share=False,
            show_error=True
        )
    else:
        print("无法创建界面，请检查数据集路径和格式")
