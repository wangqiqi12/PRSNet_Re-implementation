# NOTE: Generated by Claude Sonnet 4

"""
ShapeNet ä½“ç´ 3Dæ¨¡å‹å¯è§†åŒ–å·¥å…·

è¿™ä¸ªè„šæœ¬æä¾›äº†ä¸€ä¸ªGradioç•Œé¢æ¥æµè§ˆå’Œå¯è§†åŒ–ShapeNetCoreé£æœºæ¨¡å‹çš„ä½“ç´ æ•°æ®ã€‚
æ”¯æŒäº¤äº’å¼3DæŸ¥çœ‹ï¼ŒåŒ…æ‹¬æ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»ç­‰æ“ä½œã€‚

åŠŸèƒ½ç‰¹ç‚¹ï¼š
- è¯»å–.binvoxæ–‡ä»¶ï¼ˆsolidå’Œsurfaceä¸¤ç§ç±»å‹ï¼‰
- æ”¯æŒåˆ†è¾¨ç‡é™é‡‡æ ·ï¼ˆ128Ã—128Ã—128 â†’ 32Ã—32Ã—32ï¼‰
- 3Dä½“ç´ å¯è§†åŒ–
- äº¤äº’å¼æ§åˆ¶
"""

import os
import json
import random
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import gradio as gr
from pathlib import Path
from scipy import ndimage
import binvox_rw


class ShapeNetVoxelViewer:
    def __init__(self, dataset_path):
        self.dataset_path = Path(dataset_path)
        self.model_ids = self._get_model_ids()
        print(f"æ‰¾åˆ° {len(self.model_ids)} ä¸ª3Dä½“ç´ æ¨¡å‹")
    
    def _get_model_ids(self):
        """è·å–æ‰€æœ‰æ¨¡å‹IDåˆ—è¡¨"""
        shapenet_plane_path = self.dataset_path / "shapenet_plane"
        if not shapenet_plane_path.exists():
            return []
        
        model_ids = []
        for item in shapenet_plane_path.iterdir():
            if item.is_dir() and not item.name.startswith('.'):
                solid_path = item / "models" / "model_normalized.solid.binvox"
                surface_path = item / "models" / "model_normalized.surface.binvox"
                if solid_path.exists() or surface_path.exists():
                    model_ids.append(item.name)
        return sorted(model_ids)
    
    def load_binvox_file(self, model_id, voxel_type='solid'):
        """åŠ è½½binvoxæ–‡ä»¶"""
        if voxel_type == 'solid':
            binvox_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.solid.binvox"
        else:
            binvox_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.surface.binvox"
        
        if not binvox_path.exists():
            return None, None
        
        try:
            with open(binvox_path, 'rb') as f:
                voxel_model = binvox_rw.read_as_3d_array(f)
            return voxel_model, binvox_path
        except Exception as e:
            print(f"åŠ è½½binvoxæ–‡ä»¶æ—¶å‡ºé”™: {e}")
            return None, None
    
    def center_voxels(self, voxel_data):
        """å°†ä½“ç´ æ•°æ®å±…ä¸­åˆ°ç½‘æ ¼ä¸­å¿ƒ"""
        if voxel_data is None or not np.any(voxel_data):
            return voxel_data
        
        # è·å–å ç”¨ä½“ç´ çš„åæ ‡
        occupied_coords = np.where(voxel_data)
        if len(occupied_coords[0]) == 0:
            return voxel_data
        
        x, y, z = occupied_coords
        
        # è®¡ç®—å½“å‰è¾¹ç•Œæ¡†
        x_min, x_max = x.min(), x.max()
        y_min, y_max = y.min(), y.max()
        z_min, z_max = z.min(), z.max()
        
        # è®¡ç®—å½“å‰ç‰©ä½“çš„ä¸­å¿ƒ
        current_center = np.array([
            (x_min + x_max) / 2,
            (y_min + y_max) / 2,
            (z_min + z_max) / 2
        ])
        
        # è®¡ç®—ç½‘æ ¼çš„ä¸­å¿ƒ
        grid_center = np.array([
            voxel_data.shape[0] / 2,
            voxel_data.shape[1] / 2,
            voxel_data.shape[2] / 2
        ])
        
        # è®¡ç®—åç§»é‡
        offset = grid_center - current_center
        offset = np.round(offset).astype(int)
        
        # åˆ›å»ºæ–°çš„å±…ä¸­ä½“ç´ æ•°æ®
        centered_voxels = np.zeros_like(voxel_data)
        
        # åº”ç”¨åç§»ï¼Œç¡®ä¿ä¸è¶…å‡ºè¾¹ç•Œ
        for i in range(len(x)):
            new_x = x[i] + offset[0]
            new_y = y[i] + offset[1]
            new_z = z[i] + offset[2]
            
            # æ£€æŸ¥è¾¹ç•Œ
            if (0 <= new_x < voxel_data.shape[0] and 
                0 <= new_y < voxel_data.shape[1] and 
                0 <= new_z < voxel_data.shape[2]):
                centered_voxels[new_x, new_y, new_z] = True
        
        return centered_voxels
    
    def downsample_voxels(self, voxel_data, target_size=32):
        if voxel_data is None:
            return None
        
        original_shape = voxel_data.shape
        if all(s == target_size for s in original_shape):
            return voxel_data
        
        # è®¡ç®—ä¸‹é‡‡æ ·æ¯”ä¾‹
        scale_factors = [original_shape[i] / target_size for i in range(3)]
        
        # ä½¿ç”¨æœ€è¿‘é‚»æ’å€¼è¿›è¡Œä¸‹é‡‡æ ·
        # å…ˆè½¬æ¢ä¸ºfloatç±»å‹è¿›è¡Œæ’å€¼ï¼Œç„¶åè½¬å›bool
        voxel_float = voxel_data.astype(float)
        downsampled = ndimage.zoom(voxel_float, 
                                 [1/scale_factors[i] for i in range(3)], 
                                 order=0,  # æœ€è¿‘é‚»æ’å€¼
                                 mode='constant',
                                 cval=0.0)
        
        # ç¡®ä¿è¾“å‡ºå°ºå¯¸æ­£ç¡®
        if any(downsampled.shape[i] != target_size for i in range(3)):
            # å¦‚æœå°ºå¯¸ä¸å®Œå…¨åŒ¹é…ï¼Œä½¿ç”¨å¡«å……æˆ–è£å‰ª
            result = np.zeros((target_size, target_size, target_size), dtype=bool)
            
            min_x = min(downsampled.shape[0], target_size)
            min_y = min(downsampled.shape[1], target_size)
            min_z = min(downsampled.shape[2], target_size)
            
            result[:min_x, :min_y, :min_z] = downsampled[:min_x, :min_y, :min_z] > 0.5
            return result
        
        return downsampled > 0.5
    
    def load_model_metadata(self, model_id):
        """åŠ è½½æ¨¡å‹å…ƒæ•°æ®"""
        json_path = self.dataset_path / "shapenet_plane" / model_id / "models" / "model_normalized.json"
        
        if not json_path.exists():
            return None
        
        try:
            with open(json_path, 'r') as f:
                metadata = json.load(f)
            return metadata
        except Exception as e:
            print(f"åŠ è½½å…ƒæ•°æ®æ—¶å‡ºé”™: {e}")
            return None
    
    def create_voxel_plot(self, model_id, voxel_type='solid', target_resolution=32, 
                         opacity=0.8, colorscale='Viridis', show_only_surface=False, center_voxels=True):
        """åˆ›å»º3Dä½“ç´ å¯è§†åŒ–å›¾"""
        voxel_model, binvox_path = self.load_binvox_file(model_id, voxel_type)
        metadata = self.load_model_metadata(model_id)
        
        if voxel_model is None:
            # è¿”å›ç©ºå›¾è¡¨
            fig = go.Figure()
            fig.add_annotation(text="æ— æ³•åŠ è½½ä½“ç´ æ¨¡å‹", x=0.5, y=0.5, showarrow=False)
            return fig, "ä½“ç´ æ¨¡å‹åŠ è½½å¤±è´¥"
        
        # è·å–åŸå§‹ä½“ç´ æ•°æ®
        original_voxels = voxel_model.data
        original_dims = voxel_model.dims
        
        # ä¸‹é‡‡æ ·åˆ°ç›®æ ‡åˆ†è¾¨ç‡
        if target_resolution != original_dims[0]:
            downsampled_voxels = self.downsample_voxels(original_voxels, target_resolution)
        else:
            downsampled_voxels = original_voxels
        
        if downsampled_voxels is None:
            fig = go.Figure()
            fig.add_annotation(text="ä½“ç´ ä¸‹é‡‡æ ·å¤±è´¥", x=0.5, y=0.5, showarrow=False)
            return fig, "ä½“ç´ ä¸‹é‡‡æ ·å¤±è´¥"
        
        # å±…ä¸­ä½“ç´ ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if center_voxels:
            downsampled_voxels = self.center_voxels(downsampled_voxels)
        
        # è·å–å ç”¨ä½“ç´ çš„åæ ‡
        if show_only_surface and voxel_type == 'solid':
            # å¦‚æœé€‰æ‹©åªæ˜¾ç¤ºè¡¨é¢ï¼Œè®¡ç®—è¡¨é¢ä½“ç´ 
            from scipy import ndimage
            # è†¨èƒ€åå‡å»åŸå§‹ï¼Œå¾—åˆ°è¡¨é¢
            kernel = ndimage.generate_binary_structure(3, 1)  # 6è¿é€š
            eroded = ndimage.binary_erosion(downsampled_voxels, kernel)
            surface_voxels = downsampled_voxels & ~eroded
            occupied_coords = np.where(surface_voxels)
        else:
            occupied_coords = np.where(downsampled_voxels)
        
        if len(occupied_coords[0]) == 0:
            fig = go.Figure()
            fig.add_annotation(text="æ²¡æœ‰å ç”¨çš„ä½“ç´ ", x=0.5, y=0.5, showarrow=False)
            return fig, "æ²¡æœ‰å ç”¨çš„ä½“ç´ "
        
        x, y, z = occupied_coords
        
        # åˆ›å»ºé¢œè‰²æ˜ å°„ï¼ˆåŸºäºZåæ ‡ï¼‰
        colors = z.astype(float)
        
        # åˆ›å»º3Dæ•£ç‚¹å›¾è¡¨ç¤ºä½“ç´ 
        fig = go.Figure()
        
        scatter = go.Scatter3d(
            x=x, y=y, z=z,
            mode='markers',
            marker=dict(
                size=8,
                color=colors,
                colorscale=colorscale,
                opacity=opacity,
                showscale=True,
                colorbar=dict(title="Zåæ ‡")
            ),
            name=f'{voxel_type.title()} ä½“ç´ ',
            hovertemplate='<b>ä½“ç´ åæ ‡</b><br>' +
                         'X: %{x}<br>' +
                         'Y: %{y}<br>' +
                         'Z: %{z}<extra></extra>'
        )
        fig.add_trace(scatter)
        
        # è®¾ç½®å¸ƒå±€
        fig.update_layout(
            title=f'ä½“ç´ æ¨¡å‹: {model_id} ({voxel_type}, {target_resolution}Â³)',
            scene=dict(
                xaxis_title='Xè½´',
                yaxis_title='Yè½´', 
                zaxis_title='Zè½´',
                camera=dict(
                    eye=dict(x=1.5, y=1.5, z=1.5)
                ),
                aspectmode='cube',  # ä¿æŒç«‹æ–¹ä½“æ¯”ä¾‹
                xaxis=dict(range=[0, target_resolution]),
                yaxis=dict(range=[0, target_resolution]),
                zaxis=dict(range=[0, target_resolution])
            ),
            width=800,
            height=600,
            margin=dict(l=0, r=0, t=40, b=0)
        )
        
        # åˆ›å»ºä¿¡æ¯æ–‡æœ¬
        info_text = f"**æ¨¡å‹ID:** {model_id}\n"
        info_text += f"**ä½“ç´ ç±»å‹:** {voxel_type.title()}\n"
        info_text += f"**åŸå§‹åˆ†è¾¨ç‡:** {original_dims[0]}Ã—{original_dims[1]}Ã—{original_dims[2]}\n"
        info_text += f"**å½“å‰åˆ†è¾¨ç‡:** {target_resolution}Ã—{target_resolution}Ã—{target_resolution}\n"
        info_text += f"**åŸå§‹å ç”¨ä½“ç´ æ•°:** {np.sum(original_voxels)}\n"
        info_text += f"**å½“å‰å ç”¨ä½“ç´ æ•°:** {len(x)}\n"
        info_text += f"**åŸå§‹å ç”¨ç‡:** {np.sum(original_voxels) / original_voxels.size * 100:.2f}%\n"
        info_text += f"**å½“å‰å ç”¨ç‡:** {len(x) / (target_resolution**3) * 100:.2f}%\n"
        
        if metadata:
            info_text += f"**è¾¹ç•Œæ¡†æœ€å°å€¼:** {metadata.get('min', 'N/A')}\n"
            info_text += f"**è¾¹ç•Œæ¡†æœ€å¤§å€¼:** {metadata.get('max', 'N/A')}\n"
            info_text += f"**ä¸­å¿ƒç‚¹:** {metadata.get('centroid', 'N/A')}\n"
        
        info_text += f"\n**æ–‡ä»¶è·¯å¾„:** {binvox_path}"
        
        return fig, info_text
    
    def get_random_model(self):
        """è·å–éšæœºæ¨¡å‹ID"""
        if self.model_ids:
            return random.choice(self.model_ids)
        return ""
    
    def get_model_list(self):
        """è·å–æ¨¡å‹åˆ—è¡¨ç”¨äºä¸‹æ‹‰é€‰æ‹©"""
        return self.model_ids


def create_gradio_interface():
    """åˆ›å»ºGradioç•Œé¢"""
    
    # åˆå§‹åŒ–æŸ¥çœ‹å™¨
    # NOTE: è¯·ç¡®ä¿æ•°æ®é›†è·¯å¾„æ­£ç¡®
    # è¿™é‡Œä½¿ç”¨äº†ä¸€ä¸ªç¤ºä¾‹è·¯å¾„ï¼Œè¯·æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹
    dataset_path = "./data/ShapeNet-toydata"
    viewer = ShapeNetVoxelViewer(dataset_path)
    
    if not viewer.model_ids:
        print("æœªæ‰¾åˆ°ä»»ä½•ä½“ç´ æ¨¡å‹æ–‡ä»¶ï¼è¯·æ£€æŸ¥æ•°æ®é›†è·¯å¾„ã€‚")
        return None
    
    # å®šä¹‰ç•Œé¢å‡½æ•°
    def visualize_voxels(model_id, voxel_type, target_resolution, opacity, colorscale, show_only_surface, center_voxels):
        if not model_id:
            return None, "è¯·é€‰æ‹©ä¸€ä¸ªæ¨¡å‹"
        
        try:
            fig, info = viewer.create_voxel_plot(
                model_id, voxel_type, target_resolution, 
                opacity, colorscale, show_only_surface, center_voxels
            )
            return fig, info
        except Exception as e:
            return None, f"å¯è§†åŒ–é”™è¯¯: {str(e)}"
    
    def load_random_model():
        return viewer.get_random_model()
    
    # åˆ›å»ºGradioç•Œé¢
    with gr.Blocks(title="ShapeNet ä½“ç´ æ¨¡å‹æµè§ˆå™¨", theme=gr.themes.Soft()) as demo:
        gr.Markdown("""
        # ğŸ§Š ShapeNet ä½“ç´ æ¨¡å‹æµè§ˆå™¨
        
        è¿™æ˜¯ä¸€ä¸ªäº¤äº’å¼ä½“ç´ æ¨¡å‹æŸ¥çœ‹å·¥å…·ï¼Œç”¨äºæµè§ˆShapeNetCoreé£æœºæ•°æ®é›†çš„ä½“ç´ è¡¨ç¤ºã€‚
        
        ## åŠŸèƒ½ç‰¹ç‚¹ï¼š
        - ğŸ“Š äº¤äº’å¼3Dä½“ç´ å¯è§†åŒ–ï¼ˆæ”¯æŒæ—‹è½¬ã€ç¼©æ”¾ã€å¹³ç§»ï¼‰
        - ğŸ”„ åˆ†è¾¨ç‡ä¸‹é‡‡æ ·ï¼ˆ128Â³ â†’ 32Â³ æˆ–å…¶ä»–å°ºå¯¸ï¼‰
        - ğŸ¨ å¤šç§é¢œè‰²æ–¹æ¡ˆå’Œé€æ˜åº¦è°ƒèŠ‚
        - ğŸ§Š æ”¯æŒSolidï¼ˆå®å¿ƒï¼‰å’ŒSurfaceï¼ˆè¡¨é¢ï¼‰ä¸¤ç§ä½“ç´ ç±»å‹
        - ğŸ“‹ è¯¦ç»†çš„ä½“ç´ ç»Ÿè®¡ä¿¡æ¯
        - ğŸ² éšæœºæ¨¡å‹æµè§ˆ
        
        ## ä½¿ç”¨è¯´æ˜ï¼š
        1. é€‰æ‹©æ¨¡å‹IDå’Œä½“ç´ ç±»å‹
        2. è°ƒæ•´åˆ†è¾¨ç‡å’Œå¯è§†åŒ–é€‰é¡¹
        3. åœ¨3Då›¾ä¸­æ‹–æ‹½é¼ æ ‡æ—‹è½¬è§†è§’ï¼Œæ»šè½®ç¼©æ”¾ï¼Œå³é”®å¹³ç§»
        
        ## ä½“ç´ ç±»å‹è¯´æ˜ï¼š
        - **Solid**: å®å¿ƒä½“ç´ ï¼ŒåŒ…å«æ¨¡å‹å†…éƒ¨çš„æ‰€æœ‰ä½“ç´ 
        - **Surface**: è¡¨é¢ä½“ç´ ï¼Œä»…åŒ…å«æ¨¡å‹è¡¨é¢çš„ä½“ç´ 
        """)
        
        with gr.Row():
            with gr.Column(scale=1):
                gr.Markdown("### ğŸ® æ§åˆ¶é¢æ¿")
                
                model_dropdown = gr.Dropdown(
                    choices=viewer.get_model_list(),
                    label="é€‰æ‹©æ¨¡å‹ID",
                    value=viewer.get_random_model(),
                    info="ä»ä¸‹æ‹‰åˆ—è¡¨ä¸­é€‰æ‹©è¦æŸ¥çœ‹çš„3Dä½“ç´ æ¨¡å‹"
                )
                
                random_btn = gr.Button("ğŸ² éšæœºé€‰æ‹©æ¨¡å‹", variant="secondary")
                
                with gr.Group():
                    gr.Markdown("#### ä½“ç´ é€‰é¡¹")
                    voxel_type_radio = gr.Radio(
                        choices=['solid', 'surface'],
                        value='solid',
                        label="ä½“ç´ ç±»å‹",
                        info="é€‰æ‹©è¦æ˜¾ç¤ºçš„ä½“ç´ ç±»å‹"
                    )
                    
                    resolution_slider = gr.Slider(
                        minimum=16,
                        maximum=128,
                        step=16,
                        value=32,
                        label="ç›®æ ‡åˆ†è¾¨ç‡",
                        info="ä½“ç´ ç½‘æ ¼çš„åˆ†è¾¨ç‡ï¼ˆNÃ—NÃ—Nï¼‰"
                    )
                    
                    show_surface_checkbox = gr.Checkbox(
                        label="ä»…æ˜¾ç¤ºè¡¨é¢ï¼ˆä»…å¯¹Solidæœ‰æ•ˆï¼‰",
                        value=False,
                        info="ä»å®å¿ƒä½“ç´ ä¸­æå–å¹¶ä»…æ˜¾ç¤ºè¡¨é¢ä½“ç´ "
                    )
                    
                    center_checkbox = gr.Checkbox(
                        label="å±…ä¸­æ˜¾ç¤º",
                        value=True,
                        info="å°†ä½“ç´ æ¨¡å‹å±…ä¸­åˆ°ç½‘æ ¼ä¸­å¿ƒä½ç½®"
                    )
                
                with gr.Group():
                    gr.Markdown("#### å¯è§†åŒ–é€‰é¡¹")
                    opacity_slider = gr.Slider(
                        minimum=0.1,
                        maximum=1.0,
                        step=0.1,
                        value=0.8,
                        label="é€æ˜åº¦",
                        info="ä½“ç´ çš„é€æ˜åº¦"
                    )
                    
                    colorscale_dropdown = gr.Dropdown(
                        choices=['Viridis', 'Plasma', 'Inferno', 'Magma', 'Rainbow', 'Turbo', 'Spectral', 'Blues', 'Reds'],
                        value='Viridis',
                        label="é¢œè‰²æ–¹æ¡ˆ",
                        info="é€‰æ‹©ä½“ç´ çš„é¢œè‰²æ˜ å°„"
                    )
                
                visualize_btn = gr.Button("ğŸš€ å¯è§†åŒ–", variant="primary", size="lg")
                
                gr.Markdown(f"""
                ### ğŸ“Š æ•°æ®é›†ä¿¡æ¯
                - **æ€»æ¨¡å‹æ•°é‡**: {len(viewer.model_ids)}
                - **æ•°æ®æ ¼å¼**: Binvoxä½“ç´ 
                - **åŸå§‹åˆ†è¾¨ç‡**: 128Ã—128Ã—128
                - **ä½“ç´ ç±»å‹**: Solid + Surface
                """)
            
            with gr.Column(scale=2):
                plot_output = gr.Plot(label="3Dä½“ç´ æ¨¡å‹å¯è§†åŒ–")
                info_output = gr.Markdown("é€‰æ‹©ä¸€ä¸ªæ¨¡å‹å¼€å§‹å¯è§†åŒ–...")
        
        # äº‹ä»¶ç»‘å®š
        random_btn.click(
            fn=load_random_model,
            outputs=model_dropdown
        )
        
        visualize_btn.click(
            fn=visualize_voxels,
            inputs=[model_dropdown, voxel_type_radio, resolution_slider, 
                   opacity_slider, colorscale_dropdown, show_surface_checkbox, center_checkbox],
            outputs=[plot_output, info_output]
        )
        
        # è‡ªåŠ¨åŠ è½½ç¬¬ä¸€ä¸ªæ¨¡å‹
        demo.load(
            fn=visualize_voxels,
            inputs=[model_dropdown, voxel_type_radio, resolution_slider, 
                   opacity_slider, colorscale_dropdown, show_surface_checkbox, center_checkbox],
            outputs=[plot_output, info_output]
        )
    
    return demo


if __name__ == "__main__":
    # åˆ›å»ºå¹¶å¯åŠ¨ç•Œé¢
    demo = create_gradio_interface()
    
    if demo:
        print("å¯åŠ¨ShapeNet ä½“ç´ æ¨¡å‹æµè§ˆå™¨...")
        print("åœ¨æµè§ˆå™¨ä¸­è®¿é—®ç•Œé¢æ¥æµè§ˆä½“ç´ æ¨¡å‹")
        demo.launch(
            server_name="127.0.0.1",
            server_port=7861,  # ä½¿ç”¨ä¸åŒç«¯å£é¿å…å†²çª
            share=False,
            show_error=True
        )
    else:
        print("æ— æ³•åˆ›å»ºç•Œé¢ï¼Œè¯·æ£€æŸ¥æ•°æ®é›†è·¯å¾„å’Œæ ¼å¼")
